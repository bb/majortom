package de.topicmapslab.majortom.cache;

import java.util.Collections;
import java.util.Map;
import java.util.Set;

import org.tmapi.core.Construct;

import de.topicmapslab.majortom.model.core.IAssociation;
import de.topicmapslab.majortom.model.core.IAssociationRole;
import de.topicmapslab.majortom.model.core.IConstruct;
import de.topicmapslab.majortom.model.core.IName;
import de.topicmapslab.majortom.model.core.IOccurrence;
import de.topicmapslab.majortom.model.core.IScope;
import de.topicmapslab.majortom.model.core.ITopic;
import de.topicmapslab.majortom.model.core.IVariant;
import de.topicmapslab.majortom.model.event.ITopicMapListener;
import de.topicmapslab.majortom.model.event.TopicMapEventType;
import de.topicmapslab.majortom.util.HashUtil;

public class ConstructCache implements ITopicMapListener {

	private CharacteristicsCache characteristicsCache;
	private IdentityCache identityCache;
	private ReificationCache reificationCache;
	private ScopeCache scopeCache;
	private TypedCache typedCache;
	private TopicTypeCache topicTypeCache;
	private AssociationCache associationCache;
	private RevisionCache revisionCache;

	class CacheKey {

		/**
		 * constructor
		 * 
		 * @param parent
		 *            the parent
		 * @param type
		 *            the type
		 * @param scope
		 *            the scope
		 */
		public CacheKey(IConstruct parent, ITopic type, IScope scope) {
			this.parent = parent;
			this.type = type;
			this.scope = scope;
		}

		IConstruct parent;
		ITopic type;
		IScope scope;

		/**
		 * {@inheritDoc}
		 */
		public boolean equals(Object obj) {
			if (obj instanceof CacheKey) {
				CacheKey other = (CacheKey) obj;
				boolean result = (parent == null) ? other.parent == null : parent.equals(other.parent);
				result &= (type == null) ? other.type == null : type.equals(other.type);
				result &= (scope == null) ? other.scope == null : scope.equals(other.scope);
				return result;
			}
			return false;
		}

		/**
		 * {@inheritDoc}
		 */
		public int hashCode() {
			int hash = (parent == null) ? 0 : parent.hashCode();
			hash |= (type == null) ? 0 : type.hashCode();
			hash |= (scope == null) ? 0 : scope.hashCode();
			return hash;
		}
	}

	private Map<CacheKey, Set<IName>> names;
	private Map<CacheKey, Set<IOccurrence>> occurrences;
	private Map<CacheKey, Set<IAssociation>> associations;
	private Map<CacheKey, Set<IAssociationRole>> roles;
	private Map<CacheKey, Set<IVariant>> variants;
	private Map<CacheKey, Set<ITopic>> topics;
	private Map<Object, Set<CacheKey>> relevantCacheKeys;

	enum Key {
		UNSPECIFIED_CONTEXT,

		UNSPECIFIED_TYPE,

		UNSPECIFIED_SCOPE,
	}

	/**
	 * Generates a cache key for the given properties
	 * 
	 * @param context
	 *            the context or parent of stored values
	 * @param type
	 *            the type of stored values
	 * @param scope
	 *            the scope of stored values
	 * @return the generated cache key
	 */
	private CacheKey generateCacheKey(IConstruct context, ITopic type, IScope scope) {
		CacheKey key = new CacheKey(context, type, scope);
		if (relevantCacheKeys == null) {
			relevantCacheKeys = HashUtil.getHashMap();
		}
		Object obj = context == null ? Key.UNSPECIFIED_CONTEXT : context;
		Set<CacheKey> keys = relevantCacheKeys.get(obj);
		if (keys == null) {
			keys = HashUtil.getHashSet();
			relevantCacheKeys.put(obj, keys);
		}
		keys.add(key);

		obj = type == null ? Key.UNSPECIFIED_TYPE : type;
		keys = relevantCacheKeys.get(obj);
		if (keys == null) {
			keys = HashUtil.getHashSet();
			relevantCacheKeys.put(obj, keys);
		}
		keys.add(key);

		obj = scope == null ? Key.UNSPECIFIED_SCOPE : scope;
		keys = relevantCacheKeys.get(obj);
		if (keys == null) {
			keys = HashUtil.getHashSet();
			relevantCacheKeys.put(obj, keys);
		}
		keys.add(key);
		return key;
	}

	/**
	 * Returns all relevant cache keys for the given filter
	 * 
	 * @param obj
	 *            the filter
	 * @return a set of all relevant cache keys
	 */
	private Set<CacheKey> getRelevantCacheKeys(Object obj) {
		if (relevantCacheKeys == null || !relevantCacheKeys.containsKey(obj)) {
			return Collections.emptySet();
		}
		return relevantCacheKeys.get(obj);
	}

	/**
	 * Internal method to access the given map in a secure way. The method
	 * extracts the requested constructs from the given map by a unique key
	 * generated by the other arguments.
	 * 
	 * @param <T>
	 *            the generic type of requested constructs
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @param map
	 *            the map to extract the constructs
	 * @return a set of constructs or <code>null</code> if the given map is null
	 *         or does not contain the given key
	 */
	private <T extends IConstruct> Set<T> getConstructs(IConstruct parent, ITopic type, IScope scope, Map<CacheKey, Set<T>> map) {
		if (map == null) {
			return null;
		}
		return map.get(new CacheKey(parent, type, scope));
	}

	/**
	 * Returns the internal stored names of the given parent, the given type and
	 * the given scope
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @return all cached names
	 */
	public Set<IName> getNames(ITopic parent, ITopic type, IScope scope) {
		return getConstructs(parent, type, scope, names);
	}

	/**
	 * Returns the internal stored occurrences of the given parent, the given
	 * type and the given scope
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @return all cached occurrences
	 */
	public Set<IOccurrence> getOccurrences(ITopic parent, ITopic type, IScope scope) {
		return getConstructs(parent, type, scope, occurrences);
	}

	/**
	 * Returns the internal stored variants of the given parent and the given
	 * scope
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @return all cached variants
	 */
	public Set<IVariant> getVariants(IName parent, IScope scope) {
		return getConstructs(parent, null, scope, variants);
	}

	/**
	 * Returns the internal stored associations of the given parent, the given
	 * type and the given scope
	 * 
	 * @param context
	 *            the topic map or the playing topic or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @return all cached associations
	 */
	public Set<IAssociation> getAssociation(IConstruct context, ITopic type, IScope scope) {
		return getConstructs(context, type, scope, associations);
	}

	/**
	 * Returns the internal stored roles of the given parent, the given type
	 * 
	 * @param context
	 *            the association or the playing topic or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @return all cached roles
	 */
	public Set<IAssociationRole> getRoles(IConstruct context, ITopic type) {
		return getConstructs(context, type, null, roles);
	}

	/**
	 * Returns the internal stored topics the given type
	 * 
	 * @param type
	 *            the type or <code>null</code>
	 * @return all cached roles
	 */
	public Set<ITopic> getTopics(ITopic type) {
		return getConstructs(null, type, null, topics);
	}

	/**
	 * Cache the names of the given parent, the given type and the given scope
	 * in the internal store
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @param set
	 *            the values to cache
	 */
	public void cacheNames(ITopic parent, ITopic type, IScope scope, Set<IName> set) {
		if (names == null) {
			names = HashUtil.getHashMap();
		}
		names.put(generateCacheKey(parent, type, scope), set);
	}

	/**
	 * Cache the occurrences of the given parent, the given type and the given
	 * scope in the internal store
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * 
	 * @param set
	 *            the values to cache
	 */
	public void cacheOccurrences(ITopic parent, ITopic type, IScope scope, Set<IOccurrence> set) {
		if (occurrences == null) {
			occurrences = HashUtil.getHashMap();
		}
		occurrences.put(generateCacheKey(parent, type, scope), set);
	}

	/**
	 * Cache the variants of the given parent and the given scope in the
	 * internal store
	 * 
	 * @param parent
	 *            the parent or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @param set
	 *            the values to cache
	 */
	public void cacheVariants(IName parent, IScope scope, Set<IVariant> set) {
		if (variants == null) {
			variants = HashUtil.getHashMap();
		}
		variants.put(generateCacheKey(parent, null, scope), set);
	}

	/**
	 * Cache the associations of the given parent, the given type and the given
	 * scope in the internal store
	 * 
	 * @param context
	 *            the topic map or the playing topic or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param scope
	 *            the scope or <code>null</code>
	 * @param set
	 *            the values to cache
	 */
	public void cacheAssociation(IConstruct context, ITopic type, IScope scope, Set<IAssociation> set) {
		if (associations == null) {
			associations = HashUtil.getHashMap();
		}
		associations.put(generateCacheKey(context, type, scope), set);
	}

	/**
	 * Cache the roles of the given parent, the given type in the internal store
	 * 
	 * @param context
	 *            the association or the playing topic or <code>null</code>
	 * @param type
	 *            the type or <code>null</code>
	 * @param set
	 *            the values to cache
	 */
	public void cacheRoles(IConstruct context, ITopic type, Set<IAssociationRole> set) {
		if (roles == null) {
			roles = HashUtil.getHashMap();
		}
		roles.put(generateCacheKey(context, type, null), set);
	}

	/**
	 * Cache the topics of the given type to the internal topic map store
	 * 
	 * @param type
	 *            the type or <code>null</code>
	 * @param set
	 *            the values to cache
	 */
	public void cacheTopics(ITopic type, Set<ITopic> set) {
		if (topics == null) {
			topics = HashUtil.getHashMap();
		}
		topics.put(generateCacheKey(null, type, null), set);
	}

	/**
	 * Returns the internal reference of the sub cache handling datatypes and
	 * values
	 * 
	 * @return the reference
	 */
	public CharacteristicsCache getCharacteristicsCache() {
		if (characteristicsCache == null) {
			characteristicsCache = new CharacteristicsCache();
		}
		return characteristicsCache;
	}

	/**
	 * Returns the internal reference of the sub cache handling identities of a
	 * construct
	 * 
	 * @return the identityCache
	 */
	public IdentityCache getIdentityCache() {
		if (identityCache == null) {
			identityCache = new IdentityCache();
		}
		return identityCache;
	}

	/**
	 * Returns the internal reference of the cache handling the reification
	 * between a topic and a reified construct
	 * 
	 * @return the reificationCache
	 */
	public ReificationCache getReificationCache() {
		if (reificationCache == null) {
			reificationCache = new ReificationCache();
		}
		return reificationCache;
	}

	/**
	 * Returns the internal reference of the cache handling the scopes of a
	 * construct
	 * 
	 * @return the scopeCache
	 */
	public ScopeCache getScopeCache() {
		if (scopeCache == null) {
			scopeCache = new ScopeCache();
		}
		return scopeCache;
	}

	/**
	 * Returns the internal reference of the cache handling the types of a
	 * construct
	 * 
	 * @return the typedCache
	 */
	public TypedCache getTypedCache() {
		if (typedCache == null) {
			typedCache = new TypedCache();
		}
		return typedCache;
	}

	/**
	 * Returns the internal reference of the cache handling the topic-type
	 * hierarchy
	 * 
	 * @return the topicTypeCache
	 */
	public TopicTypeCache getTopicTypeCache() {
		if (topicTypeCache == null) {
			topicTypeCache = new TopicTypeCache();
		}
		return topicTypeCache;
	}

	/**
	 * Returns the internal cache reference handling the role-player mappings
	 * 
	 * @return the associationCache
	 */
	public AssociationCache getAssociationCache() {
		if (associationCache == null) {
			associationCache = new AssociationCache();
		}
		return associationCache;
	}

	/**
	 * Returns the internal cache reference handling the history
	 * 
	 * @return the revisionCache
	 */
	public RevisionCache getRevisionCache() {
		if (revisionCache == null) {
			revisionCache = new RevisionCache();
		}
		return revisionCache;
	}

	/**
	 * closing the cache instance
	 */
	public void clear() {
		if (associations != null) {
			associations.clear();
		}
		if (names != null) {
			names.clear();
		}
		if (occurrences != null) {
			occurrences.clear();
		}
		if (roles != null) {
			roles.clear();
		}
		if (variants != null) {
			variants.clear();
		}
		if (topics != null) {
			topics.clear();
		}
		if (topicTypeCache != null) {
			topicTypeCache.clear();
		}
		if (typedCache != null) {
			typedCache.clear();
		}
		if (characteristicsCache != null) {
			characteristicsCache.clear();
		}
		if (identityCache != null) {
			identityCache.clear();
		}
		if (reificationCache != null) {
			reificationCache.clear();
		}
		if (scopeCache != null) {
			scopeCache.clear();
		}
		if (associationCache != null) {
			associationCache.clear();
		}
		if (relevantCacheKeys != null) {
			relevantCacheKeys = HashUtil.getHashMap();
		}
		if (revisionCache != null) {
			revisionCache.clear();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public void topicMapChanged(String id, TopicMapEventType event, Construct notifier, Object newValue, Object oldValue) {
		/*
		 * a name was removed or created
		 */
		if (names != null && (event == TopicMapEventType.NAME_REMOVED || event == TopicMapEventType.NAME_ADDED)) {
			/*
			 * delete direct names of parent
			 */
			for (CacheKey key : getRelevantCacheKeys(notifier)) {
				names.remove(key);
			}
			/*
			 * delete name cache of topic map context
			 */
			for (CacheKey key : getRelevantCacheKeys(Key.UNSPECIFIED_CONTEXT)) {
				names.remove(key);
			}
		}
		/*
		 * an occurrence was removed or created
		 */
		else if (occurrences != null && (event == TopicMapEventType.OCCURRENCE_ADDED || event == TopicMapEventType.OCCURRENCE_REMOVED)) {
			/*
			 * delete direct occurrences of parent
			 */
			for (CacheKey key : getRelevantCacheKeys(notifier)) {
				occurrences.remove(key);
			}
			/*
			 * delete occurrences cache of topic map context
			 */
			for (CacheKey key : getRelevantCacheKeys(Key.UNSPECIFIED_CONTEXT)) {
				occurrences.remove(key);
			}
		}
		/*
		 * a variant was removed or created
		 */
		else if (variants != null && (event == TopicMapEventType.VARIANT_ADDED || event == TopicMapEventType.VARIANT_REMOVED)) {
			/*
			 * delete direct occurrences of parent
			 */
			for (CacheKey key : getRelevantCacheKeys(notifier)) {
				variants.remove(key);
			}
			/*
			 * delete occurrences cache of topic map context
			 */
			for (CacheKey key : getRelevantCacheKeys(Key.UNSPECIFIED_CONTEXT)) {
				variants.remove(key);
			}
		}
		/*
		 * an association was removed or created
		 */
		else if (associations != null && (event == TopicMapEventType.ASSOCIATION_ADDED || event == TopicMapEventType.ASSOCIATION_REMOVED)) {
			associations.clear();
		}
		/*
		 * a role was removed or created
		 */
		else if (roles != null && (event == TopicMapEventType.ROLE_ADDED || event == TopicMapEventType.ROLE_REMOVED)) {
			roles.clear();
		}
		/*
		 * a topic was removed or created
		 */
		else if ((event == TopicMapEventType.TOPIC_ADDED || event == TopicMapEventType.TOPIC_REMOVED)) {
			if (topics != null) {
				topics.clear();
			}
			if (names != null) {
				names.clear();
			}
			if (variants != null) {
				variants.clear();
			}
			if (occurrences != null) {
				occurrences.clear();
			}
			if (roles != null) {
				roles.clear();
			}
			if (associations != null) {
				associations.clear();
			}
		}
		/*
		 * a type was modified
		 */
		else if (event == TopicMapEventType.TYPE_SET) {
			Set<CacheKey> keys = HashUtil.getHashSet();
			// get cache keys of old type
			keys.addAll(getRelevantCacheKeys(oldValue));
			// get cache keys of new type
			keys.addAll(getRelevantCacheKeys(newValue));
			// remove all type relevant cache entries
			for (CacheKey key : keys) {
				if (names != null) {
					names.remove(key);
				}
				if (occurrences != null) {
					occurrences.remove(key);
				}
				if (roles != null) {
					roles.remove(key);
				}
				if (associations != null) {
					associations.remove(key);
				}
			}
		}
		/*
		 * a type was added or removed
		 */
		else if (topics != null && (event == TopicMapEventType.TYPE_REMOVED || event == TopicMapEventType.TYPE_ADDED)) {
			Object ref = event == TopicMapEventType.TYPE_REMOVED ? oldValue : newValue;
			// remove all type filtered topic instances
			for (CacheKey key : getRelevantCacheKeys(ref)) {
				topics.remove(key);
			}
		}
		/*
		 * scope was modified
		 */
		else if (event == TopicMapEventType.SCOPE_MODIFIED) {
			Set<CacheKey> keys = HashUtil.getHashSet();
			// get cache keys of old scope
			keys.addAll(getRelevantCacheKeys(oldValue));
			// get cache keys of new scope
			keys.addAll(getRelevantCacheKeys(newValue));
			// remove all scope relevant cache entries
			for (CacheKey key : keys) {
				if (names != null) {
					names.remove(key);
				}
				if (occurrences != null) {
					occurrences.remove(key);
				}
				if (variants != null) {
					variants.remove(key);
				}
				if (associations != null) {
					associations.remove(key);
				}
			}
		}
		/*
		 * topics are merging
		 */
		else if (event == TopicMapEventType.MERGE) {
			// clear all caches
			clear();
		}

		/*
		 * call sub caches
		 */
		if (topicTypeCache != null) {
			topicTypeCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (typedCache != null) {
			typedCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (characteristicsCache != null) {
			characteristicsCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (identityCache != null) {
			identityCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (reificationCache != null) {
			reificationCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (scopeCache != null) {
			scopeCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (associationCache != null) {
			associationCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
		if (revisionCache != null) {
			revisionCache.topicMapChanged(id, event, notifier, newValue, oldValue);
		}
	}
}
